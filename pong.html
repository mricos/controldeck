<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pong - ControlDeck Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            background: #0a0a0f;
            color: #e0e0e0;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 800px;
            margin-bottom: 20px;
        }
        h1 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, #fff, #888);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .status {
            font-size: 12px;
            padding: 6px 12px;
            background: #12141a;
            border: 1px solid #2a2d35;
            border-radius: 20px;
            color: #666;
        }
        .status.connected {
            color: #6fc;
            border-color: rgba(74,170,136,0.3);
            background: rgba(74,170,136,0.1);
        }
        .game-container {
            position: relative;
            background: linear-gradient(180deg, #181a20, #15171d);
            border: 2px solid #2a2d35;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 30px rgba(0,0,0,0.4);
        }
        canvas {
            display: block;
            border-radius: 4px;
        }
        .score-board {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            font-size: 32px;
            font-weight: bold;
        }
        .score-board .p1 { color: #4a8; }
        .score-board .p2 { color: #84a; }
        .controls-info {
            margin-top: 20px;
            max-width: 800px;
            width: 100%;
            background: linear-gradient(180deg, #181a20, #15171d);
            border: 1px solid #2a2d35;
            border-radius: 10px;
            padding: 16px 20px;
        }
        .controls-info h3 {
            font-size: 11px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        .control-row {
            display: flex;
            gap: 30px;
            font-size: 13px;
            color: #aaa;
        }
        .control-row div {
            flex: 1;
        }
        .control-row span {
            color: #6fc;
        }
        .input-display {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #2a2d35;
            display: flex;
            gap: 40px;
        }
        .input-display .player {
            flex: 1;
        }
        .input-display h4 {
            font-size: 10px;
            color: #555;
            text-transform: uppercase;
            margin-bottom: 6px;
        }
        .axis-bar {
            height: 8px;
            background: #12141a;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            margin-bottom: 4px;
        }
        .axis-bar::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #333;
        }
        .axis-fill {
            height: 100%;
            background: #4a8;
            transition: width 0.05s, margin-left 0.05s;
            border-radius: 4px;
        }
        .axis-value {
            font-size: 11px;
            color: #555;
            font-family: monospace;
        }
        .buttons {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }
        .btn {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid #3a3d45;
            color: #888;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .btn:hover {
            border-color: #5a5d65;
            color: #ccc;
        }
        .btn.active {
            background: rgba(74,170,136,0.15);
            border-color: #4a8;
            color: #6fc;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>PONG</h1>
        <div class="buttons">
            <button id="btn-keyboard" class="btn active">Keyboard</button>
            <button id="btn-gamepad" class="btn">Gamepad</button>
            <button id="btn-virtual" class="btn">ControlDeck</button>
        </div>
        <div id="status" class="status">Press any key or connect gamepad</div>
    </div>

    <div class="game-container">
        <div class="score-board">
            <span class="p1" id="score-p1">0</span>
            <span>:</span>
            <span class="p2" id="score-p2">0</span>
        </div>
        <canvas id="game" width="700" height="400"></canvas>
    </div>

    <div class="controls-info">
        <h3>Controls</h3>
        <div class="control-row">
            <div><span>Player 1:</span> W/S keys or Left Stick Y-axis</div>
            <div><span>Player 2:</span> Up/Down arrows or Right Stick Y-axis</div>
            <div><span>Pause:</span> Space or Start button</div>
        </div>
        <div class="input-display">
            <div class="player">
                <h4>Player 1 (Left Stick)</h4>
                <div class="axis-bar"><div class="axis-fill" id="p1-axis"></div></div>
                <div class="axis-value" id="p1-value">0.000</div>
            </div>
            <div class="player">
                <h4>Player 2 (Right Stick)</h4>
                <div class="axis-bar"><div class="axis-fill" id="p2-axis"></div></div>
                <div class="axis-value" id="p2-value">0.000</div>
            </div>
        </div>
    </div>

    <!-- Include the polyfill for virtual gamepad support -->
    <script>
        // Configure polyfill before it loads
        // Using channel 'pong' for ControlDeck AI integration
        window.CONTROLDECK_OPTIONS = {
            channel: 'pong',
            realGamepads: true,
            virtualIndex: 'auto',
            debug: true
        };
    </script>
    <script src="controldeck-polyfill.js"></script>

    <script>
    (function() {
        'use strict';

        // =====================================================================
        // GAME CONFIG
        // =====================================================================
        const CONFIG = {
            paddleWidth: 12,
            paddleHeight: 80,
            paddleSpeed: 8,
            ballRadius: 8,
            ballSpeed: 6,
            maxBallSpeed: 14,
            speedIncrease: 0.3,
            winScore: 11
        };

        // =====================================================================
        // GAME STATE
        // =====================================================================
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        let inputMode = 'keyboard'; // 'keyboard', 'gamepad', 'virtual'
        let gamepadConnected = false;
        let virtualConnected = false;
        let paused = false;
        let gameOver = false;

        const state = {
            p1: { y: canvas.height / 2, score: 0, input: 0 },
            p2: { y: canvas.height / 2, score: 0, input: 0 },
            ball: { x: canvas.width / 2, y: canvas.height / 2, vx: 5, vy: 2 },
            keys: {}
        };

        // BroadcastChannel for sending game state to ControlDeck AI
        const stateChannel = new BroadcastChannel('controldeck-pong-state');

        function broadcastGameState() {
            stateChannel.postMessage({
                type: 'gamestate',
                ballX: state.ball.x,
                ballY: state.ball.y,
                ballVx: state.ball.vx,
                ballVy: state.ball.vy,
                p1Y: state.p1.y,
                p2Y: state.p2.y,
                canvasWidth: canvas.width,
                canvasHeight: canvas.height,
                paddleHeight: CONFIG.paddleHeight,
                paused: paused,
                gameOver: gameOver
            });
        }

        // =====================================================================
        // INPUT HANDLING
        // =====================================================================

        // Keyboard
        document.addEventListener('keydown', (e) => {
            state.keys[e.code] = true;
            if (e.code === 'Space') {
                paused = !paused;
                if (gameOver) resetGame();
            }
        });
        document.addEventListener('keyup', (e) => {
            state.keys[e.code] = false;
        });

        function processKeyboardInput() {
            state.p1.input = 0;
            state.p2.input = 0;

            if (state.keys['KeyW'] || state.keys['KeyA']) state.p1.input = -1;
            if (state.keys['KeyS'] || state.keys['KeyD']) state.p1.input = 1;
            if (state.keys['ArrowUp']) state.p2.input = -1;
            if (state.keys['ArrowDown']) state.p2.input = 1;
        }

        function processGamepadInput() {
            const gamepads = navigator.getGamepads();
            let gp = null;

            // Find first connected gamepad
            for (let i = 0; i < gamepads.length; i++) {
                if (gamepads[i] && gamepads[i].connected) {
                    gp = gamepads[i];
                    break;
                }
            }

            if (!gp) {
                if (gamepadConnected || virtualConnected) {
                    gamepadConnected = false;
                    virtualConnected = false;
                    updateStatus();
                }
                return;
            }

            // Check if it's a virtual or real gamepad
            const isVirtual = gp.id.includes('ControlDeck') || gp.id.includes('Virtual');

            if (!gamepadConnected && !isVirtual) {
                gamepadConnected = true;
                updateStatus();
            }
            if (!virtualConnected && isVirtual) {
                virtualConnected = true;
                updateStatus();
            }

            // Left stick Y-axis controls P1
            const leftY = gp.axes[1] || 0;
            // Right stick Y-axis controls P2
            const rightY = gp.axes[3] || 0;

            // Apply deadzone
            const deadzone = 0.15;
            state.p1.input = Math.abs(leftY) > deadzone ? leftY : 0;
            state.p2.input = Math.abs(rightY) > deadzone ? rightY : 0;

            // Update axis display
            updateAxisDisplay(leftY, rightY);

            // Start button to pause
            if (gp.buttons[9] && gp.buttons[9].pressed) {
                if (!state._startPressed) {
                    paused = !paused;
                    if (gameOver) resetGame();
                    state._startPressed = true;
                }
            } else {
                state._startPressed = false;
            }

            // D-pad as fallback
            if (gp.buttons[12]?.pressed) state.p1.input = -1; // up
            if (gp.buttons[13]?.pressed) state.p1.input = 1;  // down
            if (gp.buttons[0]?.pressed) state.p2.input = -1;  // A = up
            if (gp.buttons[1]?.pressed) state.p2.input = 1;   // B = down
        }

        function updateAxisDisplay(p1Val, p2Val) {
            const p1Bar = document.getElementById('p1-axis');
            const p2Bar = document.getElementById('p2-axis');
            const p1Value = document.getElementById('p1-value');
            const p2Value = document.getElementById('p2-value');

            // Convert -1..1 to visual position
            const toVisual = (v) => {
                const width = Math.abs(v) * 50;
                const left = v < 0 ? (50 - width) : 50;
                return { width: width + '%', marginLeft: left + '%' };
            };

            const v1 = toVisual(p1Val);
            const v2 = toVisual(p2Val);

            p1Bar.style.width = v1.width;
            p1Bar.style.marginLeft = v1.marginLeft;
            p2Bar.style.width = v2.width;
            p2Bar.style.marginLeft = v2.marginLeft;

            p1Value.textContent = p1Val.toFixed(3);
            p2Value.textContent = p2Val.toFixed(3);
        }

        function updateStatus() {
            const el = document.getElementById('status');
            if (virtualConnected) {
                el.textContent = 'ControlDeck connected';
                el.classList.add('connected');
            } else if (gamepadConnected) {
                el.textContent = 'Gamepad connected';
                el.classList.add('connected');
            } else {
                el.textContent = 'Press any key or connect gamepad';
                el.classList.remove('connected');
            }
        }

        // =====================================================================
        // GAME LOGIC
        // =====================================================================

        function resetBall(direction = 1) {
            state.ball.x = canvas.width / 2;
            state.ball.y = canvas.height / 2;
            const angle = (Math.random() - 0.5) * Math.PI / 3;
            state.ball.vx = CONFIG.ballSpeed * direction * Math.cos(angle);
            state.ball.vy = CONFIG.ballSpeed * Math.sin(angle);
        }

        function resetGame() {
            state.p1.score = 0;
            state.p2.score = 0;
            state.p1.y = canvas.height / 2;
            state.p2.y = canvas.height / 2;
            gameOver = false;
            paused = false;
            resetBall(1);
            updateScoreboard();
        }

        function updateScoreboard() {
            document.getElementById('score-p1').textContent = state.p1.score;
            document.getElementById('score-p2').textContent = state.p2.score;
        }

        function update() {
            // Always process gamepad (real or virtual) - allows AI to control
            processGamepadInput();

            // Also process keyboard input (can override gamepad)
            if (inputMode === 'keyboard') {
                processKeyboardInput();
            } else {
                // Keyboard as fallback in gamepad modes
                if (state.keys['KeyW'] || state.keys['KeyS']) {
                    state.p1.input = state.keys['KeyW'] ? -1 : 1;
                }
                if (state.keys['ArrowUp'] || state.keys['ArrowDown']) {
                    state.p2.input = state.keys['ArrowUp'] ? -1 : 1;
                }
            }

            if (paused || gameOver) return;

            // Move paddles
            state.p1.y += state.p1.input * CONFIG.paddleSpeed;
            state.p2.y += state.p2.input * CONFIG.paddleSpeed;

            // Clamp paddles
            const halfPaddle = CONFIG.paddleHeight / 2;
            state.p1.y = Math.max(halfPaddle, Math.min(canvas.height - halfPaddle, state.p1.y));
            state.p2.y = Math.max(halfPaddle, Math.min(canvas.height - halfPaddle, state.p2.y));

            // Move ball
            state.ball.x += state.ball.vx;
            state.ball.y += state.ball.vy;

            // Ball collision with top/bottom
            if (state.ball.y - CONFIG.ballRadius < 0 || state.ball.y + CONFIG.ballRadius > canvas.height) {
                state.ball.vy = -state.ball.vy;
                state.ball.y = state.ball.y < canvas.height / 2 ? CONFIG.ballRadius : canvas.height - CONFIG.ballRadius;
            }

            // Ball collision with paddles
            const p1Left = CONFIG.paddleWidth * 2;
            const p2Right = canvas.width - CONFIG.paddleWidth * 2;

            // P1 paddle (left)
            if (state.ball.x - CONFIG.ballRadius < p1Left &&
                state.ball.y > state.p1.y - halfPaddle &&
                state.ball.y < state.p1.y + halfPaddle &&
                state.ball.vx < 0) {
                const hitPos = (state.ball.y - state.p1.y) / halfPaddle;
                const angle = hitPos * Math.PI / 4;
                const speed = Math.min(CONFIG.maxBallSpeed, Math.abs(state.ball.vx) + CONFIG.speedIncrease);
                state.ball.vx = speed * Math.cos(angle);
                state.ball.vy = speed * Math.sin(angle);
                state.ball.x = p1Left + CONFIG.ballRadius;
            }

            // P2 paddle (right)
            if (state.ball.x + CONFIG.ballRadius > p2Right &&
                state.ball.y > state.p2.y - halfPaddle &&
                state.ball.y < state.p2.y + halfPaddle &&
                state.ball.vx > 0) {
                const hitPos = (state.ball.y - state.p2.y) / halfPaddle;
                const angle = hitPos * Math.PI / 4;
                const speed = Math.min(CONFIG.maxBallSpeed, Math.abs(state.ball.vx) + CONFIG.speedIncrease);
                state.ball.vx = -speed * Math.cos(angle);
                state.ball.vy = speed * Math.sin(angle);
                state.ball.x = p2Right - CONFIG.ballRadius;
            }

            // Scoring
            if (state.ball.x < 0) {
                state.p2.score++;
                updateScoreboard();
                if (state.p2.score >= CONFIG.winScore) {
                    gameOver = true;
                } else {
                    resetBall(-1);
                }
            }
            if (state.ball.x > canvas.width) {
                state.p1.score++;
                updateScoreboard();
                if (state.p1.score >= CONFIG.winScore) {
                    gameOver = true;
                } else {
                    resetBall(1);
                }
            }
        }

        // =====================================================================
        // RENDERING
        // =====================================================================

        function render() {
            // Clear
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Center line
            ctx.setLineDash([10, 10]);
            ctx.strokeStyle = '#2a2d35';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(canvas.width / 2, 0);
            ctx.lineTo(canvas.width / 2, canvas.height);
            ctx.stroke();
            ctx.setLineDash([]);

            // Paddles
            const halfPaddle = CONFIG.paddleHeight / 2;

            // P1 paddle with glow
            ctx.shadowColor = '#4a8';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#4a8';
            ctx.fillRect(
                CONFIG.paddleWidth,
                state.p1.y - halfPaddle,
                CONFIG.paddleWidth,
                CONFIG.paddleHeight
            );

            // P2 paddle with glow
            ctx.shadowColor = '#84a';
            ctx.fillStyle = '#84a';
            ctx.fillRect(
                canvas.width - CONFIG.paddleWidth * 2,
                state.p2.y - halfPaddle,
                CONFIG.paddleWidth,
                CONFIG.paddleHeight
            );

            ctx.shadowBlur = 0;

            // Ball with glow
            ctx.shadowColor = '#fff';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(state.ball.x, state.ball.y, CONFIG.ballRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Pause/Game Over overlay
            if (paused || gameOver) {
                ctx.fillStyle = 'rgba(10, 10, 15, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 36px SF Mono, Monaco, monospace';
                ctx.textAlign = 'center';

                if (gameOver) {
                    const winner = state.p1.score >= CONFIG.winScore ? 'PLAYER 1' : 'PLAYER 2';
                    ctx.fillText(`${winner} WINS!`, canvas.width / 2, canvas.height / 2 - 20);
                    ctx.font = '16px SF Mono, Monaco, monospace';
                    ctx.fillStyle = '#888';
                    ctx.fillText('Press SPACE or START to play again', canvas.width / 2, canvas.height / 2 + 30);
                } else {
                    ctx.fillText('PAUSED', canvas.width / 2, canvas.height / 2);
                }
            }
        }

        // =====================================================================
        // MODE BUTTONS
        // =====================================================================

        document.getElementById('btn-keyboard').addEventListener('click', function() {
            inputMode = 'keyboard';
            updateModeButtons();
        });

        document.getElementById('btn-gamepad').addEventListener('click', function() {
            inputMode = 'gamepad';
            updateModeButtons();
        });

        document.getElementById('btn-virtual').addEventListener('click', function() {
            inputMode = 'virtual';
            updateModeButtons();
        });

        function updateModeButtons() {
            document.querySelectorAll('.buttons .btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById('btn-' + inputMode).classList.add('active');
        }

        // =====================================================================
        // GAME LOOP
        // =====================================================================

        function gameLoop() {
            update();
            render();
            broadcastGameState(); // Send state to ControlDeck AI
            requestAnimationFrame(gameLoop);
        }

        // Initialize
        resetBall(1);
        gameLoop();

        // Gamepad connection events
        window.addEventListener('gamepadconnected', (e) => {
            console.log('Gamepad connected:', e.gamepad.id);
            if (e.gamepad.id.includes('ControlDeck') || e.gamepad.id.includes('Virtual')) {
                virtualConnected = true;
                // Auto-switch to ControlDeck mode
                inputMode = 'virtual';
                updateModeButtons();
            } else {
                gamepadConnected = true;
                // Auto-switch to gamepad mode
                inputMode = 'gamepad';
                updateModeButtons();
            }
            updateStatus();
        });

        window.addEventListener('gamepaddisconnected', (e) => {
            console.log('Gamepad disconnected:', e.gamepad.id);
            gamepadConnected = false;
            virtualConnected = false;
            updateStatus();
        });

    })();
    </script>
</body>
</html>
